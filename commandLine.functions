# Based on sysexits.h (refer to FreeBSD man pages at http://www.gsp.com/cgi-bin/man.cgi?topic=sysexits)

# successful termination (aka EXIT_SUCCESS in stdlib.h)
readonly core_commandLine_exitCode_OK=0

# Not in sysexit, but so commonly used (aka EXIT_FAILURE in stdlib.h)
readonly core_commandLine_exitCode_FAILURE=1

# Not in sysexit, misuse of builtin
readonly core_commandLine_exitCode_MISUSEBUILTIN=2

# command line usage error
readonly core_commandLine_exitCode_USAGE=64

# data format error
readonly core_commandLine_exitCode_DATAERR=65

# cannot open input
readonly core_commandLine_exitCode_NOINPUT=66

# addressee unknown
readonly core_commandLine_exitCode_NOUSER=67

# host name unknown
readonly core_commandLine_exitCode_NOHOST=68

# service unavailable
readonly core_commandLine_exitCode_UNAVAILABLE=69

# internal software error
readonly core_commandLine_exitCode_SOFTWARE=70

# system error (e.g., can't fork)
readonly core_commandLine_exitCode_OSERR=71

# critical OS file missing
readonly core_commandLine_exitCode_OSFILE=72

# can't create (user) output file
readonly core_commandLine_exitCode_CANTCREAT=73

# input/output error
readonly core_commandLine_exitCode_IOERR=74

# temp failure; user is invited to retry
readonly core_commandLine_exitCode_TEMPFAIL=75

# remote error in protocol
readonly core_commandLine_exitCode_PROTOCOL=76

# permission denied
readonly core_commandLine_exitCode_NOPERM=77

# configuration error
readonly core_commandLine_exitCode_CONFIG=78

core_commandLine_helpMessage()
{
	_program_commandLine_helpMessage
	
	printf '%s' "${global_ourName}
$_program_commandLine_helpMessage_description

Usage 1: ${global_ourName} -h|--help
Usage 2: ${global_ourName} [-v [verbosity]|--verbose [verbosity]]${_program_commandLine_helpMessage_optionsAndNonOptions}

Usages
    1       Show Help
    2       $_program_commandLine_helpMessage_usageMessage

Options without Argments
    Switch  Long-Switch  Explanation            Default
    -h      --help       show this help
    -v      --verbose    be more verbose        ${core_init_verbosity}"

	if [ -n "$_program_commandLine_helpMessage_argumentedOptions" ]; then
		printf '%s' "$_program_commandLine_helpMessage_argumentedOptions"
	else
		printf '\n'
	fi
	
	printf '%s\n' "We do not support concatenated short options (eg -hv) or arguments (eg -v4)"
	
	if [ -n "$_program_commandLine_helpMessage_argumentlessOptions" ]; then
		printf '%s' "Options with Arguments
Switch  Default
$_program_commandLine_helpMessage_argumentlessOptions"
	else
		:
	fi
	
	if [ -n "$_program_commandLine_helpMessage_nonOptionArguments" ]; then
		printf '%s' "Non-Options
$_program_commandLine_helpMessage_nonOptionArguments
Specify -- before the non-options to separate them from option arguments"
	fi

	printf '%s' "
Path Files
A path file is used to define the location of essential programs used during initial bootstrapping. It also defines a packageManager
to automatically install any missing dependencies.
"
}

core_commandLine_versionMessage()
{
	printf '%s' \
"
$_program_name ($_program_package) $_program_version
Copyright $_program_copyright
License ${_program_licence}: $_program_licence_description
"
}

core_commandLine_exitVersion()
{
	core_commandLine_versionMessage 1>&2
	exit $core_commandLine_exitCode_OK
}

core_commandLine_exitHelp()
{
	core_commandLine_helpMessage 1>&2
	exit $core_commandLine_exitCode_OK
}

core_commandLine_exitBadCommandLine()
{
	core_message FAIL "$1"
	core_commandLine_helpMessage 1>&2
	exit $core_commandLine_exitCode_USAGE
}

core_commandLine_setLanguageDefaultsSoSortIsStableAndAnyErrorMessageParsingLogicIsReliable()
{
	unset LANG
	unset LC_COLLATE
	unset LC_CTYPE
	unset LC_MESSAGES
	unset LC_MONETARY
	unset LC_NUMERIC
	unset LC_TIME
	unset LC_ALL

	export LANG="$core_init_language"
	export LC_COLLATE="$core_init_language"
	export LC_CTYPE="$core_init_language"
	export LC_MESSAGES="$core_init_language"
	export LC_MONETARY="$core_init_language"
	export LC_NUMERIC="$core_init_language"
	export LC_TIME="$core_init_language"
	export LC_ALL=""
	
	# ? Also LANGUAGE, a GNU gettext extension?
	# ignored if locale is set to 'C'
	# pt is same as pt_PT for this variable
	# export LANGUAGE=sv:de  for swedish then german
}

# yes-argumentless
# yes-argumented
# yes-optionally-argumented
# no
core_commandLine_optionExists()
{
	case "$optionName" in
		
		h|help)
			echo yes-argumentless
		;;
	
		v|verbose)
			echo yes-optionally-argumented
		;;
		
		version)
			echo yes-argumentless
		;;
		
		*)
			_program_commandLine_optionExists
		;;
		
	esac
}

core_commandLine_processOptionWithoutArgument()
{
	case "$optionName" in
		
		h|help)
			core_commandLine_exitHelp
		;;
	
		v|verbose)
			core_init_verbosity=$((core_init_verbosity+1))
		;;
		
		version)
			core_commandLine_exitVersion
		;;
	
		*)
			_program_commandLine_processOptionWithoutArgument
		;;
		
	esac
}

core_commandLine_processOptionWithArgument()
{
	case "$optionName" in
		
		v|verbose)
			core_TODO Check value is an unsigned integer
			core_init_verbosity="$optionValue"
		;;
		
		*)
			_program_commandLine_processOptionWithArgument
		;;
		
	esac
}

# This can be confused with XF86-style long options
core_commandLine_parseConcatenatedOptionsWithoutEquals()
{
	local arguments="-${optionName}"
	local optstring=":${optionName}"
	local lastOption=${#optionName}
	local OPTARG
	local OPTERR
	local OPTIND=1
	
	while getopts "$optstring" optionName "$arguments"
	do
		optionNameIncludingHyphens="-${optionName}"
		argument="$optionNameIncludingHyphens"
		
		if [ $OPTIND -eq $lastOption ]; then
			return 0
		fi

		case "$(core_commandLine_optionExists)" in
			
			no)
				core_commandLine_exitBadCommandLine "The option '${optionNameIncludingHyphens}' is not known"
			;;
			
			yes-argumentless|yes-optionally-argumented)
				core_commandLine_processOptionWithoutArgument
			;;
			
			yes-argumented)
				core_commandLine_exitBadCommandLine "The option '${optionNameIncludingHyphens}' requires an argument which could not be specified"
			;;
			
			*)
				core_exitError "Please implement yes-argumented, yes-argumentless, yes-argument-optional or no for option '$optionName' in _program_commandLine_optionExists()"
			;;
			
		esac
		
	done
}

# POSIX: http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap12.html
# We do not support concatenated arguments (ie instead -o arg, -oarg)
# We do not support concatenated short options (ie -tvf vs -t -v -f)
core_commandLine_parse()
{
	_program_commandLine_parseInitialise
	
	local argument
	local parsingOptionArguments=0
	while [ $# -ne 0 ]
	do
		local argument="$1"
		
		if core_compatibility_startsWith "$argument" '--' ; then
			
			shift 1
		
			if [ "$argument" = '--' ]; then
				break
			fi
			
			# Parse GNU-style long options
			case "$argument" in
				
				# eg --log-level=debug (handles spaces and multiple = signs correctly)
				--*=*)
					local optionNameIncludingHyphens="${argument%%=*}"
					local optionName="${optionNameIncludingHyphens##--}"
					local optionValue="${argument#*=}"
					
					case "$(core_commandLine_optionExists)" in
						
						no)
							core_commandLine_exitBadCommandLine "The option '${optionNameIncludingHyphens}' does not exist"
						;;
						
						yes-argumentless)
							core_commandLine_exitBadCommandLine "The option '${optionNameIncludingHyphens}' does not take values (such as '$optionValue')"
						;;
						
						yes-argumented|yes-optionally-argumented)
							core_commandLine_processOptionWithArgument
						;;
						
						*)
							core_exitError "Please implement yes-argumented, yes-argumentless, yes-argument-optional or no for option '$optionName' in _program_commandLine_optionExists()"
						;;
					esac
				;;
				
				# eg --help and --verbose [level]
				--*)
					local optionNameIncludingHyphens=="$argument"
					local optionName="${argument##--}"
	
					case "$(core_commandLine_optionExists)" in
						
						no)
							core_commandLine_exitBadCommandLine "The option '${optionNameIncludingHyphens}' is not known"
						;;
						
						yes-argumentless)
							core_commandLine_processOptionWithoutArgument
						;;
						
						yes-argumented)
							if [ $# -eq 0]; then
								core_commandLine_exitBadCommandLine "The option '${optionNameIncludingHyphens}' requires an argument which was not specified"
							fi
							local optionValue="$1"
							shift 1
							core_commandLine_processOptionWithArgument
						;;
						
						yes-optionally-argumented)
							if [ $# -eq 0 ]; then
								break
							fi
							local optionValue="$1"
							if core_compatibility_startsWith "$optionValue" '--' ; then
								core_commandLine_processOptionWithoutArgument
							else
								shift 1
								core_commandLine_processOptionWithArgument
							fi
						;;
						
						*)
							core_exitError "Please implement yes-argumented, yes-argumentless, yes-argument-optional or no for option '$optionName' in _program_commandLine_optionExists()"
						;;
						
					esac
				;;
				
				*)
					core_exitError "The function core_commandLine_parse failed on argument '$argument', the line was '$@'"
				;;
			esac
			
		elif core_compatibility_startsWith "$argument" '-' ; then
			
			shift 1
			
			# Processing short options (-t, -v, etc)
			
			case "$argument" in
				
				# eg -l='debug'
				-*=*)
					local optionNameIncludingHyphens="${argument%%=*}"
					local optionName="${optionNameIncludingHyphens##-}"
					local optionValue="${argument#*=}"
					if [ ${#optionNameIncludingHyphens} -gt 2 ]; then
						# When this returns, all options will have been consumed apart from the last one, and optionName/optionNameIncludingHyphens will be a single option
						core_commandLine_parseConcatenatedOptionsWithoutEquals
					fi
					
					case "$(core_commandLine_optionExists)" in
						
						no)
							core_commandLine_exitBadCommandLine "The option '$optionNameIncludingHyphens' is not known"
						;;
						
						yes-argumentless)
							core_commandLine_exitBadCommandLine "The option '$optionNameIncludingHyphens' does not take values (such as '$optionValue')"
						;;
						
						yes-argumented|yes-optionally-argumented)
							core_commandLine_processOptionWithArgument
						;;
						
						*)
							core_exitError "Please implement yes-argumented, yes-argumentless, yes-argument-optional or no for option '$optionName' in _program_commandLine_optionExists()"
						;;
						
					esac
					
				;;
				
				# eg --help and --verbose [level]
				-*)
					local optionNameIncludingHyphens="$argument"
					local optionName="${argument##-}"
					if [ ${#optionNameIncludingHyphens} -gt 2 ]; then
						# When this returns, all options will have been consumed apart from the last one, and optionName/optionNameIncludingHyphens will be a single option
						core_commandLine_parseConcatenatedOptionsWithoutEquals
					fi
	
					case "$(core_commandLine_optionExists)" in
						
						no)
							core_commandLine_exitBadCommandLine "The option '${optionNameIncludingHyphens}' is not known"
						;;
						
						yes-argumentless)
							core_commandLine_processOptionWithoutArgument
						;;
						
						yes-argumented)
							if [ $# -eq 0]; then
								core_commandLine_exitBadCommandLine "The option '${optionNameIncludingHyphens}' requires an argument which was not specified"
							fi
							local optionValue="$1"
							shift 1
							core_commandLine_processOptionWithArgument
						;;
						
						yes-optionally-argumented)
							if [ $# -eq 0 ]; then
								break
							fi
							local optionValue="$1"
							if core_compatibility_startsWith "$optionValue" '--' ; then
								core_commandLine_processOptionWithoutArgument
							else
								shift 1
								core_commandLine_processOptionWithArgument
							fi
						;;
						
						*)
							core_exitError "Please implement yes-argumented, yes-argumentless, yes-argument-optional or no for option '$optionName' in _program_commandLine_optionExists()"
						;;
						
					esac
				;;
				
				*)
					core_exitError "The function core_commandLine_parse failed on argument '$argument', the line was '$@'"
				;;
				
			esac
		else
			# start of non-options
			break
		fi
	done
	
	_program_commandLine_handleNonOptions "$@"
	
	_program_commandLine_validate
}
