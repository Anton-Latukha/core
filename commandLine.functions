core_commandLine_helpMessage()
{
	_program_commandLine_helpMessage
	
	printf '%s' "${global_ourName}
$_program_commandLine_helpMessage_description

Usage 1: ${global_ourName} -h|--help
Usage 2: ${global_ourName} [-v [verbosity]|--verbose [verbosity]]${_program_commandLine_helpMessage_optionsAndNonOptions}

Usages
    1       Show Help
    2       $_program_commandLine_helpMessage_usageMessage

Options without Argments
    Switch  Long-Switch  Explanation            Default
    -h      --help       show this help
    -v      --verbose    be more verbose        ${core_init_verbosity}"

	if [ -n "$_program_commandLine_helpMessage_argumentedOptions" ]; then
		printf '%s' "$_program_commandLine_helpMessage_argumentedOptions"
	else
		printf '\n'
	fi
	
	printf '%s\n' "We do not support concatenated short options (eg -hv) or arguments (eg -v4)"
	
	if [ -n "$_program_commandLine_helpMessage_argumentlessOptions" ]; then
		printf '%s' "Options with Arguments
Switch  Default
$_program_commandLine_helpMessage_argumentlessOptions"
	else
		:
	fi
	
	if [ -n "$_program_commandLine_helpMessage_nonOptionArguments" ]; then
		printf '%s' "Non-Options
$_program_commandLine_helpMessage_nonOptionArguments
Specify -- before the non-options to separate them from option arguments"
	fi

	printf '%s' "
Path Files
A path file is used to define the location of essential programs used during initial bootstrapping. It also defines a packageManager
to automatically install any missing dependencies.
"
}

core_commandLine_exitHelp()
{
	core_commandLine_helpMessage 1>&2
	exit 2
}

core_commandLine_setLanguageDefaultsSoSortIsStableAndAnyErrorMessageParsingLogicIsReliable()
{
	unset LANG
	unset LC_COLLATE
	unset LC_CTYPE
	unset LC_MESSAGES
	unset LC_MONETARY
	unset LC_NUMERIC
	unset LC_TIME
	unset LC_ALL

	export LANG="$core_init_language"
	export LC_COLLATE="$core_init_language"
	export LC_CTYPE="$core_init_language"
	export LC_MESSAGES="$core_init_language"
	export LC_MONETARY="$core_init_language"
	export LC_NUMERIC="$core_init_language"
	export LC_TIME="$core_init_language"
	export LC_ALL=""
	
	# ? Also LANGUAGE, a GNU gettext extension?
	# ignored if locale is set to 'C'
	# pt is same as pt_PT for this variable
	# export LANGUAGE=sv:de  for swedish then german
}

core_commandLine_parse_longOption()
{
	longOptionValue="$(core_compatibility_indirectVariableValue $OPTIND)"
	#longOptionValue="${!OPTIND}"
	
	OPTIND=$((OPTIND+1))
	longOptionName="$OPTARG"
}

core_commandLine_parse_longOption_noValue()
{
	core_commandLine_parse_longOption
	if [ -n "$longOptionValue" ]; then
		core_exitError "The --${longOptionName} option does not take arguments (eg '${longOptionValue}')"
	fi
}

core_commandLine_parse_longOptionEquals()
{
	longOptionValue="${OPTARG#*=}"
	longOptionName="${OPTARG%=$longOptionValue}"
}

core_commandLine_parse_longOptionEquals_noValue()
{
	core_commandLine_parse_longOptionEquals
	if [ -n "$longOptionValue" ]; then
		core_commandLine_exitError "The --${longOptionName} option does not take arguments (eg '${longOptionValue}')"
	fi
}

core_commandLine_parse_longOptionUnknown()
{
	if [ "$OPTERR" = 1 ] && [ "${optspec:0:1}" != ":" ]; then
		core_commandLine_exitError "Invalid option --${OPTARG}"
	fi
}







core_compatibility_startsWith()
{
	[ "${1#${2}}" != "$1" ]
}

#_program_commandLine_optionExists()
#{
#	echo no
#}

# yes-argumentless
# yes-argumented
# yes-optionally-argumented
# no
core_commandLine_optionExists()
{
	case "$optionName" in
		
		h|help)
			echo yes-argumentless
		;;
	
		v|verbose)
			echo yes-optionally-argumented
		;;
	
		*)
			_program_commandLine_optionExists
		;;
		
	esac
}

core_commandLine_processOptionWithoutArgument()
{
	case "$optionName" in
		
		h|help)
			core_commandLine_exitHelp
		;;
	
		v|verbose)
			core_commandLine_verbosity=$((core_commandLine_verbosity+1))
		;;
	
		*)
			_program_commandLine_processOptionWithoutArgument
		;;
		
	esac
}

core_commandLine_processOptionWithArgument()
{
	case "$optionName" in
		
		v|verbose)
			core_TODO Check value is an unsigned integer
			core_commandLine_verbosity="$optionValue"
		;;
		
		*)
			_program_commandLine_processOptionWithArgument
		;;
		
	esac
}

# POSIX: http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap12.html
# We do not support concatenated arguments (ie instead -o arg, -oarg)
# We do not support concatenated short options (ie -tvf vs -t -v -f)
core_commandLine_parse()
{
	_program_commandLine_parseInitialise
	
	local argument
	local parsingOptionArguments=0
	while true
	do
		local argument="$1"
		
		if core_compatibility_startsWith "$argument" '--' ; then
			
			shift 1
		
			if [ "$argument" = '--' ]; then
				break
			fi
			
			case "$argument" in
				
				# eg --log-level=debug (handles spaces and multiple = signs correctly)
				--*=*)
					local optionNameIncludingHyphens="${argument%%=*}"
					local optionName="${optionNameIncludingHyphens##--}"
					local optionValue="${argument#*=}"
					
					case "$(core_commandLine_optionExists)" in
						
						no)
							core_exitError "The option '${optionNameIncludingHyphens}' does not exist"
						;;
						
						yes-argumentless)
							core_exitError "The option '${optionNameIncludingHyphens}' does not take values (such as '$optionValue')"
						;;
						
						yes-argumented|yes-optionally-argumented)
							core_commandLine_processOptionWithArgument
						;;
						
						*)
							core_exitError "Please implement yes-argumented, yes-argumentless, yes-argument-optional or no for option '$optionName' in _program_commandLine_optionExists()"
						;;
					esac
				;;
				
				# eg --help and --verbose [level]
				--*)
					local optionNameIncludingHyphens=="$argument"
					local optionName="${argument##--}"
	
					case "$(core_commandLine_optionExists)" in
						
						no)
							core_exitError "The option '${optionNameIncludingHyphens}' is not known"
						;;
						
						yes-argumentless)
							core_commandLine_processOptionWithoutArgument
						;;
						
						yes-argumented)
							if [ $# -eq 0]; then
								core_exitError "The option '${optionNameIncludingHyphens}' requires an argument which was not specified"
							fi
							local optionValue="$1"
							shift 1
							core_commandLine_processOptionWithArgument
						;;
						
						yes-optionally-argumented)
							if [ $# -eq 0 ]; then
								break
							fi
							local optionValue="$1"
							if core_compatibility_startsWith "$optionValue" '--' ; then
								core_commandLine_processOptionWithoutArgument
							else
								shift 1
								core_commandLine_processOptionWithArgument
							fi
						;;
						
						*)
							core_exitError "Please implement yes-argumented, yes-argumentless, yes-argument-optional or no for option '$optionName' in _program_commandLine_optionExists()"
						;;
						
					esac
				;;
				
				*)
					core_exitError "The function core_commandLine_parse failed on argument '$argument', the line was '$@'"
				;;
			esac
			
		elif core_compatibility_startsWith "$argument" '-' ; then
			
			shift 1
			
			# Processing short options (-t, -v, etc)
			
			case "$argument" in
				
				# eg -l='debug'
				-*=*)
					local optionNameIncludingHyphens="${argument%%=*}"
					if [ ${#optionNameIncludingHyphens} -gt 2 ]; then
						core_exitError "Concatenated options such as '${optionNameIncludingHyphens}' are not supported (it's just too hard in pure POSIX sh)"
					fi
					local optionName="${optionNameIncludingHyphens##-}"
					local optionValue="${argument#*=}"
					
					case "$(core_commandLine_optionExists)" in
						
						no)
							core_exitError "The option '$optionNameIncludingHyphens' is not known"
						;;
						
						yes-argumentless)
							core_exitError "The option '$optionNameIncludingHyphens' does not take values (such as '$optionValue')"
						;;
						
						yes-argumented|yes-optionally-argumented)
							core_commandLine_processOptionWithArgument
						;;
						
						*)
							core_exitError "Please implement yes-argumented, yes-argumentless, yes-argument-optional or no for option '$optionName' in _program_commandLine_optionExists()"
						;;
						
					esac
					
				;;
				
				# eg --help and --verbose [level]
				-*)
					local optionNameIncludingHyphens="$argument"
					if [ ${#optionNameIncludingHyphens} -gt 2 ]; then
						core_exitError "Concatenated options such as '${optionNameIncludingHyphens}' are not supported (it's just too hard in pure POSIX sh)"
					fi
					local optionName="${argument##-}"

	
					case "$(core_commandLine_optionExists)" in
						
						no)
							core_exitError "The option '${optionNameIncludingHyphens}' is not known"
						;;
						
						yes-argumentless)
							core_commandLine_processOptionWithoutArgument
						;;
						
						yes-argumented)
							if [ $# -eq 0]; then
								core_exitError "The option '${optionNameIncludingHyphens}' requires an argument which was not specified"
							fi
							local optionValue="$1"
							shift 1
							core_commandLine_processOptionWithArgument
						;;
						
						yes-optionally-argumented)
							if [ $# -eq 0 ]; then
								break
							fi
							local optionValue="$1"
							if core_compatibility_startsWith "$optionValue" '--' ; then
								core_commandLine_processOptionWithoutArgument
							else
								shift 1
								core_commandLine_processOptionWithArgument
							fi
						;;
						
						*)
							core_exitError "Please implement yes-argumented, yes-argumentless, yes-argument-optional or no for option '$optionName' in _program_commandLine_optionExists()"
						;;
						
					esac
				;;
				
				*)
					core_exitError "The function core_commandLine_parse failed on argument '$argument', the line was '$@'"
				;;
				
			esac
		else
			# start of non-options
			break
		fi
	done
	
	_program_commandLine_handleNonOptions "$@"
	
	_program_commandLine_validate
}
