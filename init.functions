core_init_isFattening()
{
	core_variable_isSet _program_fattening
}

core_compatibility_basename()
{
	printf '%s' "${1##*/}"
}

core_compatibility_which()
{
	command -v "$1"
}

core_compatibility_whichNoOutput()
{
	core_compatibility_which "$1" 1>/dev/null 2>/dev/null
}

core_variable_isSet()
{
	local variableName="$1"
	eval "[ \"\${$variableName+set}\" = 'set' ]"
}

core_variable_isUnset()
{
	local variableName="$1"
	eval "[ \"\${$variableName+unset}\" != 'unset' ]"
}

core_variable_indirectValue()
{
	local variableName="$1"
	eval "core_variable_indirectValue_result=\"\$${variableName}\""
}

if core_init_isFattening; then
	core_dependency_declares()
	{
		_program_fattening_declares "$@"
	}
else
	core_dependency_declares()
	{
		:
	}
fi

core_libraryName=shellfire
core_dependency_declares core_libraryName

_core_dependency_requires=''
core_dependency_declares _core_dependency_requires
core_dependency_requires()
{
	# Or '*' for all
	local packageManager="$1"
	if [ -z "$packageManager" ]; then
		# core_commandLine_exitCode_SOFTWARE
		core_exitError 70 "packageManager can not be empty"
	fi
	shift 1
	
	local programName
	for programName in "$@"
	do
		if [ -z "$programName" ]; then
			# core_commandLine_exitCode_SOFTWARE
			core_exitError 70 "programName can not be empty"
		fi
		_core_dependency_requires="${_core_dependency_requires}${packageManager}${core_variable_array_delimiter}${programName}
"
	done
}

# More for documentation than anything else for now
core_dependency_oneOf()
{
	# Or '*' for all
	local packageManager="$1"
	if [ -z "$packageManager" ]; then
		# core_commandLine_exitCode_SOFTWARE
		core_exitError 70 "packageManager can not be empty"
	fi
	shift 1
	local programName
	for programName in "$@"
	do
		:
	done
}

# More for documentation than anything else for now
core_dependency_fallback()
{
	# eg !bash
	local condition="$1"
	
	local programNameOnPath
	for programNameOnPath in "$@"
	do
		:
	done
}

core_message()
{
	local messageKind="$1"
	local message="$2"
	
	local shouldEcho=0
	local prefix=''
	local suffix=''
	case "$messageKind" in
	
		FAIL)
			if [ -t 2 ]; then
				# http://wiki.bash-hackers.org/scripting/terminalcodes
				prefix="$(printf '\033[1m\033[31m')"
				suffix="$(printf '\033[0m')"
			fi
			shouldEcho=1
		;;
		
		WARN)
			if [ -t 2 ]; then
				prefix="$(printf '\033[1m\033[33m')"
				suffix="$(printf '\033[0m')"
			fi
			shouldEcho=1
		;;
	
		INFO)
			if core_variable_isSet core_init_verbosity; then
				if [ $core_init_verbosity -gt 0 ]; then
					if [ -t 2 ]; then
						prefix="$(printf '\033[1m\033[34m')"
						suffix="$(printf '\033[0m')"
					fi
					shouldEcho=1
				fi
			fi
		;;
	
		DEBUG)
			if core_variable_isSet core_init_verbosity; then
				if [ $core_init_verbosity -gt 1 ]; then
					shouldEcho=1
				fi
			fi
		;;
		
		TODO)
			if [ -t 2 ]; then
				prefix="$(printf '\033[2m')"
				suffix="$(printf '\033[0m')"
			fi
			shouldEcho=1
		;;
	
		*)
			shouldEcho=1
		;;

	esac
	
	if [ $shouldEcho -eq 1 ]; then
		printf '%s%s%s\n' "$prefix" "$_program_name: $messageKind: $message" "$suffix" 1>&2
	fi
}

core_exitError()
{
	core_message FAIL "$2"
	exit $1
}

core_TODO()
{
	core_message TODO "$*"
}

# Does not work as a delimiter when running bash as /bin/sh on Mac - seems to be an IFS bug in bash 3.2
#core_variable_array_delimiter="$(printf '\001')"
core_variable_array_delimiter=','
core_dependency_declares core_variable_array_delimiter

core_dependency_declares _core_uses_alreadySourced
# Duplicates logic in core/variable/array, but that is a hefty piece to pull in and breaks code (as the bash overrides handle arrays differently)
# Has a defect such that function paths containing '0x01' can be loaded more than once [highly unlikely except as a potential security defect]
# By specifying $1 as not , say, /usr/lib, and $2 as something other than core_libraryName, this code can be used for plugins
core_uses()
{
	local libPath="$1"
	local libraryName="$2"
	shift 2
	
	local namespacedModule
	local moduleName
	local sourced
	local functionsFilePath
	
	# TODO: Does NOT WORK when using /bin/sh on Mac - implying older bash run as sh is broken
	local delimiter="$core_variable_array_delimiter"
	
	for namespacedModule in "$@"
	do
		namespacedModule="$libraryName"/"$namespacedModule"
		
		# Skip if already sourced
		local originalIFS="$IFS"
		local IFS="$delimiter"
		if core_variable_isUnset _core_uses_alreadySourced; then
			_core_uses_alreadySourced="${namespacedModule}"
		else
			for alreadySourcedNamespacedFunction in $_core_uses_alreadySourced
			do
				if [ "$namespacedModule" = "$alreadySourcedNamespacedFunction" ]; then
					continue 2
				fi
			done
			_core_uses_alreadySourced="${_core_uses_alreadySourced}${delimiter}${namespacedModule}"
		fi
		local IFS="$originalIFS"
		
		# Source
		moduleName="$(core_compatibility_basename "$namespacedModule")"
		sourced=0
		for relativeFunctionsFilePath in "$namespacedModule" "$namespacedModule"."$core_init_preferredShell" "$namespacedModule"/"$moduleName" "$namespacedModule"/"$moduleName"."$core_init_preferredShell"
		do
			functionsFilePath="$libPath"/"$relativeFunctionsFilePath".functions
			if [ -f "$functionsFilePath" ]; then
				# core_commandLine_exitCode_OSFILE
				. "$functionsFilePath" || core_exitError 72 "Can not load functions '$functionsFilePath'"
				sourced=1
			fi
		done
		if [ $sourced -eq 0 ]; then
			# core_commandLine_exitCode_OSFILE
			core_exitError 72 "Can not load functions for module '$namespacedModule'"
		fi
	done
}

core_usesIn()
{
	if [ $# -eq 1 ]; then
		local parentNamespace=''
	else
		local parentNamespace="${1}/"
		shift 1
	fi
	
	local module
	for module in "$@"
	do
		core_uses "$_program_libPath" "$core_libraryName" "${parentNamespace}${module}"
	done
}

core_init_defines()
{
	:
}

core_init_init()
{
	set -e
	set -u
}

core_init_setSaneEnvironmentDefaults()
{
	set +o allexport
	set +o emacs
	set -o errexit
	set +o ignoreeof
	set +o monitor
	set +o noclobber
	set +o noexec
	# aka set -f; disable globbing by default. Note that this is the opposite of usual behaviour
	set -o noglob
	set +o nolog
	set +o notify
	set -o nounset
	set +o verbose
	set +o vi
	
	# unset will fail if, and only if, we've been source'd and they have been made readonly. Unlikely.
	
	# MUST be unset before making use of cd
	unset CDPATH
	unset HISTSIZE
	unset MAILCHECK
	unset MAILPATH
	unset ENV
	
	# bash specific, but since at this stage of execution we can't be sure we're running under bash, we do nothing
	unset BASH_ENV
	unset BASH_XTRACEFD
	unset FCEDIT
	unset FIGNORE
	unset FUNCNEST
	unset GLOBIGNORE
	unset HISTCONTROL
	unset HISTFILE
	unset HISTFILESIZE
	unset HISTIGNORE
	unset HISTTIMEFORMAT
	unset HOSTFILE
	unset IGNOREEOF
	unset INPUTRC
	unset MAIL
	unset TMOUT
}

# http://mywiki.wooledge.org/BashFAQ/028 on $0
# http://mywiki.wooledge.org/Bashism?action=show&redirect=bashism
core_init_findOurNameAndPath()
{
	global_ourSymlinkName="$(core_compatibility_basename "$0")"
		
	# can be empty if 'bash file' used or 'bash </path/to/file' or ksh with PATH containing '.'
	_local_ourSymlinkPathRaw="${0%/*}"
	if [ -z "$_local_ourSymlinkPathRaw" ]; then
		# core_commandLine_exitCode_USAGE
		core_exitError 64 "Do not invoke this program either by specifying a shell interpreter on a file in the current working directory (eg bash '$0') or redirecting from a pipe into a shell interpreter (eg bash [-c] <'$0') or by using ksh with a PATH containing '.'"
	fi
	
	# At this point, we resolve $0 vs the current working directory
	# If we were exec'd, we have either a relative or an absolute path
	cd "$_local_ourSymlinkPathRaw" 1>/dev/null
		global_ourSymlinkPath="$(pwd)"
	cd - >/dev/null
	
	cd -P "$_local_ourSymlinkPathRaw" 1>/dev/null
		global_ourPath="$(pwd)"
	cd - >/dev/null
	
	unset _local_ourSymlinkPathRaw
	
	global_ourSymlinkExecutablePath="$global_ourSymlinkPath"/"$global_ourSymlinkName"
}

core_init_doNotRunAsSetUidOrSetGid()
{
	# Not a great defence; real purpose is to defeat a sysadmin making this script setuid/setgid:-
	# * Happens too late, really - the shell interpreter is running
	# * bash allows functions to be exported that can replace builtins (even the builtin builtin)
	
	if [ -u "$global_ourSymlinkExecutablePath" ]; then
		# core_commandLine_exitCode_NOPERM
		core_exitError 77 "We can not be run with the setuid bit set"
	fi
	
	if [ -g "$global_ourSymlinkExecutablePath" ]; then
		# core_commandLine_exitCode_NOPERM
		core_exitError 77 "We can not be run with setgid bit set"
	fi
}

core_init_determinePreferredShell()
{
	_local_shebang_path
	_local_shebang_shell
	_local_remainder
	_local_comment
	_local_shebang_path
	
	IFS=' ' read -r _local_commented_shebang_path _local_shebang_shell _local_remainder <"$global_ourSymlinkExecutablePath"
	if [ -n "$_local_remainder" ]; then
		# core_commandLine_exitCode_SOFTWARE
		core_exitError 70 "Passing options to a shell ('#!$_local_shebang_path $_local_shebang_shell $_local_remainder') is not supported"
	fi
	IFS='!' read -r _local_comment _local_shebang_path <<-EOF
		$_local_commented_shebang_path
	EOF
	
	if [ -z "$_local_shebang_shell" ]; then
		core_init_preferredShell="$(core_compatibility_basename "$_local_shebang_path")"
	else
		if [ "$_local_shebang_path" != '/usr/bin/env' ]; then
			# core_commandLine_exitCode_SOFTWARE
			core_exitError 70 "All shell scripts should use '/usr/bin/env' with a shell, not #!$_local_shebang_path $shebang_shell"
		fi
		core_init_preferredShell="$_local_shebang_shell"
	fi
	
	unset _local_shebang_path
	unset _local_shebang_shell
	unset _local_remainder
	unset _local_comment
	unset _local_shebang_path
}

# Ensures we run under a shell interpreter that we were designed for - no matter what is specified in the shebang
# This works around packaging tools that want '#!/bin/bash', but point to an old version. Needs to be coupled into loading new shell versions.
core_init_rexecUnderCorrectShell()
{
	if core_variable_isSet core_init_shell_rexecing; then
		if [ "$core_init_shell_rexecing" = "$$" ]; then
			# we've been successfully re-exec'd
			unset core_init_shell_rexecing
			return 0
		fi
	fi

	if ! core_compatibility_whichNoOutput "$core_init_preferredShell"; then
		#core_commandLine_exitCode_OSFILE
		core_exitError 72 "Preferred shell '$core_init_preferredShell' does not exist on the PATH"
	fi
	_local_shellPath="$(core_compatibility_which "$core_init_preferredShell")"

	# exec -a doesn't work in dash
	if [ "$core_init_preferredShell" = 'bash' ]; then
		# Forces a privileged shell. Not a great defence.
		core_init_shell_rexecing=$$ exec "$_local_shellPath" -p "$global_ourSymlinkExecutablePath" "$@"
	else
		core_init_shell_rexecing=$$ exec "$_local_shellPath" "$global_ourSymlinkExecutablePath" "$@"
	fi
	
	unset _local_shellPath
}

core_init_setTracing()
{
	case "$-" in
		
		*x*)
			if core_variable_isSet shellfire_trace; then
				export shellfire_trace="$shellfire_trace $_program_name"
			else
				export shellfire_trace="$_program_name"
			fi
		;;
		
		*)
			# Known to not be correct for space-delimited program names
			if core_variable_isSet shellfire_trace; then
				_local_program
				for _core_init_setTracing_program in $shellfire_trace
				do
					if [ "$program" = "$_program_name" ]; then
						set -x
						break
					fi
				done
			fi
			unset _local_program
		;;
		
	esac
}

core_init_setLocalSupport()
{
	case "$core_init_preferredShell" in

		# Needed for ksh93 (tested on ksh93u).
		# pdksh, mksh have this alias by default.
		# dash, bash, ash in BusyBox and zsh support local natively
		# OpenBSD ksh, and oksh (derived from OpenBSD ksh) local support is unknown.
		ksh|ksh93|ksh93u)
			alias local='typeset'
		;;
		
	esac
}

core_init_main()
{
	core_init_init
	core_init_setSaneEnvironmentDefaults
	core_init_findOurNameAndPath
	core_init_setLocalSupport
	core_init_determinePreferredShell
	core_init_rexecUnderCorrectShell "$@"
	core_init_setTracing
	core_init_setLocalSupport
	
	core_usesIn core
	if core_functions_exists _program; then
		_program
	else
		:
	fi

	if core_init_isFattening; then
		return 0
	fi
	core_functions_execute _core_functions "$@"
	${_program_entrypoint}
}

core_init_main "$@"
