core_usesIn core functions path compatibility
core_usesIn core/dependency check
core_usesIn core/variable array

core_init_defines core_dependency_requires
core_init_defines core_dependency_fallback

# There are several sources of commonly used tools in linux that provide 'core' utils with differing switches, etc.
# Despite POSIX, these are still quite incompatible.
# In rough popularity:-
# * GNU coreutils, findutils et al
# * Busybox
# * BSD userland (Mac OS X variant and *BSD variant, with slight differences between the *BSDs)
# * Toybox (up and coming)
# * Heirloom (http://heirloom.sourceforge.net/tools.html)
# * Proprietary Unix: Solaris, AIX and HP-UX (with everything else effectively now an also-ran)
# * Various other bits and bobs (see toybox)

# Also uname -s (part of coreutils, often at /bin/uname, so quite reliably present)
# See Gnu shtool http://www.gnu.org/software/shtool/ (slow)
# See Gnu config.guess http://git.savannah.gnu.org/gitweb/?p=config.git;a=blob;f=config.guess;hb=HEAD (yuck)
# See getconf (part of IEEE Std 1003.1-2001 / Posix.1), part of libc-bin on Ubuntu, for other neat stuff
core_dependency_fallback !bash uname
core_dependency_determineOsFamily()
{
	# supported by bash, might be set externally or in configuration; the most reliable way to detect OS as it's built in
	if core_variable_isSet OSTYPE; then
		case "$OSTYPE" in
		
			cygwin)
				core_dependency_osFamily=cygwin
			;;
		
			# eg linux-gnu
			linux*)
				core_dependency_osFamily=linux
			;;
		
			# Part of MinGW, eg Git Bash and msysGit
			msys)
				core_dependency_osFamily=msys
			;;
		
			# darwin12 [Mountain Lion], darwin9.0 [Leopard]
			darwin*)
				core_dependency_osFamily=macosx
			;;
		
			# ?
			solaris*)
				core_dependency_osFamily=solaris
			;;
		
			# ?
			# netbsd is known; freebsd et al are guesses
			netbsd|freebsd|openbsd)
				core_dependency_osFamily=bsd
			;;
		
			*)
				core_message WARN "The bash OSTYPE '$OSTYPE' is unsupported"
				core_dependency_osFamily='Unsupported'
			;;
		
		esac
	else
		# https://en.wikipedia.org/wiki/Uname
		# -o is more useful but most BSD derivatives don't support it
		local unameSystem="$(uname -s)"
		case "$unameSystem" in
			
			CYGWIN_*)
			:
			;;
			
			Linux)
				core_dependency_osFamily=linux
			;;
			
			Darwin)
				core_dependency_osFamily=macosx
			;;
			
			SunOS)
				core_dependency_osFamily=solaris
			;;
			
			MINGW*|MSYS_*)
				core_dependency_osFamily=msys
			;;
			
			DragonFly|NetBSD|FreeBSD|*BSD)
				core_dependency_osFamily=bsd
			;;
			
			# Debian/Hurd and Debian/kFreeBSD both use a GNU/Linux user space
			GNU|GNU/kFreeBSD)
				core_dependency_osFamily=linux
			;;
			
			# Last release August 2012
			# Also, support MKS Toolkit, etc - but is it really worth it?
			# And UnxUtils, dead since 2007
			UWIN-*)
				core_dependency_osFamily=Unsupported
			;;
			
			HP-UX)
				core_dependency_osFamily=Unsupported
			;;
			
			AIX)
				core_dependency_osFamily=Unsupported
			;;
			
			OS400)
				core_dependency_osFamily=Unsupported
			;;
			
			OS/390)
				core_dependency_osFamily=Unsupported
			;;
			
			Haiku)
				core_dependency_osFamily=Unsupported
			;;

			QNX)
				core_dependency_osFamily=Unsupported
			;;
			
			NONSTOP_KERNEL)
				core_dependency_osFamily=Unsupported
			;;
			
			# Cray Unicos, MINIX, IRIX, IRIX64, Tru64, Ultrix, SCO, UnixWare, UWIN, SINIX, ReliantUNIX
			sn5176|MINIX|IRIX|IRIX64|OSF|ULTRIX|SCO_SV|UnixWare|Interix|SINIX-*|ReliantUNIX-*)
				core_dependency_osFamily=Obsolete
			;;
	
			*)
				core_dependency_osFamily=Unsupported
			;;
			
		esac
		
		if [ "$core_dependency_osFamily" = 'Obsolete' ]; then
			core_message WARN "The uname system (uname -s) '$unameSystem' is obsolete; it is probable this program will not work"
		elif [ "$core_dependency_osFamily" = 'Unsupported' ]; then
			core_message INFO "The uname system (uname -s) '$unameSystem' is unsupported"
		fi
	fi
}
core_functions_register _core_dependency_functions core_dependency_determineOsFamily

# We need to think about bash 3.1, 3.2, 4.1 and 4.2 support; supporting Mac OS X and msys out-of-the-box is advantageous
core_dependency_ensureWeAreRunningBash4()
{
	if [ "$core_init_preferredShell" = 'bash' ]; then
		if [ "${BASH_VERSINFO[0]}" != "4" ]; then
			# Of major OS vendors, only RHEL 6 / CentOS 6 still use bash 4.1 (which lacks some declare syntax for arrays)
			local errorMessage='You are not using bash 4'
			case "$core_dependency_osFamily" in
				
				msys)
					errorMessage="${errorMessage}. MinGW, git-bash (msysGit / Git for Windows https://msysgit.github.io/) and other MSYS based Windows products ship an obsolete version of bash (which could be upgraded according to this thread http://mingw.5.n7.nabble.com/bash-4-x-for-MSYS-td5605.html). Please use Cygwin instead"
				;;
				
				macosx)
					errorMessage="${errorMessage}. On Mac OS X, install Homebrew (see http://brew.sh/ ) and then  brew install bash ."
				;;
				
			esac
			core_exitError $core_commandLine_exitCode_OSFILE "$errorMessage"
		fi
		if [ "${BASH_VERSINFO[1]}" -lt 2 ]; then
			# Ubuntu 14.04 using 4.3, 12.04 uses 4.2; 10.04 is obsolete in 8 months
			# AIX using 4.2
			# OpenSolaris 11 shipped 4.1
			# RHEL6/CentOS6 shipped 4.1
			# Cygwin using 4.1
			# Mac OS X using 3.2 (still)
			# MinGW uses 3.1 (!)
			core_exitError $core_commandLine_exitCode_OSFILE "You are not using at least bash 4.2"
		fi
	fi
}
core_functions_register _core_dependency_functions core_dependency_ensureWeAreRunningBash4

core_dependency_fallback !'*' lsb_release
core_dependency_determinePackageManager()
{
	if core_variable_array_iterateAsCallbacksShortcut core_dependency_check_functions; then
		return 0
	fi
	
	# Alternatively, we can use /etc/debian_version's presence in a check above
	# Or parse /etc/lsb-release for DISTRIB_ID
	if core_compatibility_whichNoOutput lsb_release; then
		local lsbDistributor="$(lsb_release --id --short)"
		if [ -n "$lsbDistributor" ]; then
			readonly core_dependency_packageManager="$lsbDistributor"
			return 0
		fi
	fi
	
	core_dependency_packageManager='Unknown'
}
core_functions_register _core_dependency_functions core_dependency_determinePackageManager

_core_dependency_addToPackagesToInstallIfRequired()
{
	if core_variable_array_contains packagesToInstall "$pathPackage"; then
		return 0
	fi
	core_variable_array_append packagesToInstall "$pathPackage"
}

_core_dependency_addToReplacementPathIfRequired()
{
	local filePath="$1"
	local folderPath="$(core_compatibility_dirname "$filePath")"
	local replacementPathFragment
	local IFS=':'
	for replacementPathFragment in $replacementPath
	do
		if [ "$replacementPathFragment" = "$folderPath" ]; then
			return 0
		fi
	done
	replacementPath="$folderPath:$replacementPath"
}

_core_dependency_addFromInternalDataSource()
{
	local internalDataSourceName="_core_dependency_internalDataSource_${packageManager}_${programName}"
	
	if core_variable_isUnset "$internalDataSourceName"; then
		foundInternally=0
		return 0
	fi
	foundInternally=1

	local core_variable_indirectValue_result
	core_variable_indirectValue "$internalDataSourceName"
	IFS=' ' read -r pathProgramName pathPackage pathAbsoluteFilePath <<-EOF
		$core_variable_indirectValue_result
	EOF
	
	# We use an existence check. This allows for more complex installatons, eg brew-rmtree, which don't install binaries
	if [ ! -e "$pathAbsoluteFilePath" ]; then
		_core_dependency_addToPackagesToInstallIfRequired
		_core_dependency_addToReplacementPathIfRequired	"$pathAbsoluteFilePath"
	fi
}

_core_dependency_addFromExternalDataSources()
{
	local externalDataSourceFolderPath
	local externalDataSourceFilePath
	
	# First encountered path wins
	for externalDataSourceFolderPath in \
		"$HOME"/."$_program_name" \
		"$HOME"/."$core_libraryName" \
		"$core_init_etcPath"/"$_program_name" \
		"$core_init_etcPath"/"$core_libraryName"
	do
		externalDataSourceFilePath="$externalDataSourceFolderPath"/paths.d/"$packageManager"/"$programName".path
		if ! core_path_isReadableNonEmptyFilePath "$externalDataSourceFilePath"; then
			continue
		fi
		
		IFS=' ' read -r pathProgramName pathPackage pathAbsoluteFilePath <"$externalDataSourceFilePath"
		
		# We use an existence check. This allows for more complex installatons, eg brew-rmtree, which don't install binaries
		if [ ! -e "$pathAbsoluteFilePath" ]; then
			_core_dependency_addToPackagesToInstallIfRequired
		fi
		_core_dependency_addToReplacementPathIfRequired	"$pathAbsoluteFilePath"
		foundInternally=1
		return
	done
}

core_dependency_add()
{
	local pathProgramName
	local pathPackage
	local pathAbsoluteFilePath
	
	local foundInternally=0
	_core_dependency_addFromInternalDataSource
	if [ $foundInternally -eq 0 ]; then
		_core_dependency_addFromExternalDataSources
	fi
	if [ $foundInternally -eq 0 ]; then
		core_message WARN "Dependency '$programName' for packageManager '$packageManager' not in any known .path file (or internally)"
		return 0
	fi
	
	if [ "$(core_compatibility_basename "$pathAbsoluteFilePath")" = "$programName" ]; then
		return 0
	fi
	
	# Make a temporary folder to contain a symlink to this program so names work correctly; add to the path
	if [ -z "$temporaryPathForWeirdlyLinkedFiles" ]; then
		local TMP_FOLDER
		core_temporaryFiles_newFolderToRemoveOnExit
		temporaryPathForWeirdlyLinkedFiles="$TMP_FOLDER"
		replacementPath="$temporaryPathForWeirdlyLinkedFiles:$replacementPath"
	fi
	ln -s "$pathAbsoluteFilePath" "$temporaryPathForWeirdlyLinkedFiles"/"$programName" 
}

# Special bash-ism
command_not_found_handle()
{
	local programNotFound="$1"
	shift 1
	core_exitError $core_commandLine_exitCode_OSFILE "Essential dependency '$programNotFound' not found on the PATH (with arguments $@)"
}

core_dependency_setUpPathAndInstallMissing()
{
	# A standard path, excluding games, but including any sibling binaries to our one
	local replacementPath='/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'
	_core_dependency_addToReplacementPathIfRequired "$global_ourSymlinkPath"
	_core_dependency_addToReplacementPathIfRequired "$global_ourPath"
	
	if [ "$core_dependency_packageManager" = 'Unknown' ]; then
		core_message INFO 'Could not determine package manager for your system, located binaries may be incorrect'
	fi
	
	local alreadyHandledProgramNames
	core_variable_array_initialise alreadyHandledProgramNames
	
	local packagesToInstall
	core_variable_array_initialise packagesToInstall
	
	local temporaryPathForWeirdlyLinkedFiles=''
	
	local packageManager
	local programName
	local alreadyInstalledProgramName
	local oldIFS="$IFS"
	local IFS="$(printf '\001')"
	while IFS="$(printf '\001')" read -r packageManager programName
	do
		local IFS="$oldIFS"
		case "$packageManager" in
			
			'*'|"$core_dependency_packageManager")
				packageManager="$core_dependency_packageManager"
				if core_variable_array_contains alreadyHandledProgramNames "$programName"; then
					continue
				fi
				core_variable_array_append alreadyHandledProgramNames "$programName"
				core_dependency_add
			;;

			# Because of the heredoc, there's an extra blank line. A messy alternative is https://unix.stackexchange.com/questions/102891/posix-compliant-way-to-work-with-a-list-of-filenames-possibly-with-whitespace
			'')
				break
			;;
			
			*)
				continue
			;;
			
		esac
	done <<-EOF
		${_core_dependency_requires}
	EOF
	local IFS="$oldIFS"
	
	if [ $(core_variable_array_length packagesToInstall) -ne 0 ]; then
		core_message WARN "Installing missing packages '$(core_variable_array_string packagesToInstall " ")'"
		core_variable_array_passToFunctionAsArguments packagesToInstall core_dependency_check_${core_dependency_packageManager}_packageManager
	fi
	
	# Alternative: The only trully defensive measure is to create a tmp folder, then symlink binaries from it. This requires mktemp, and so there's a potential issue with using this logic during boot-time
	
	
	# In bash, this cleans the path; hash -r is for other shells
	export PATH="$replacementPath"
	hash -r
}
core_functions_register _core_dependency_functions core_dependency_setUpPathAndInstallMissing

core_dependency_installDependencies()
{
	core_functions_execute _core_dependency_functions "$@"
}
